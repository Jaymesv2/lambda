use std::str::FromStr;

use crate::{
    ident_env::{IdentEnv, Id},
    parser::{
        parse_tree::*,
        pos::*,
        tokenizer::*,
        grammar::Error,
    }
};

use std::vec::Vec;

//grammar<'input, 'env, Id>(src: &'input str, type_cache: &TypeCache<Id, ArcType<Id>>, env: MutIdentEnv<'env, Id>, errors: ErrorEnv<'env, 'input>) where Id: Clone;

grammar<'a, 'b>(src: &'a str, ident_env: &'b mut IdentEnv);

extern {
    type Location = BytePos;
    type Error = Spanned<TokenizerError, BytePos>;

    enum Token<'a> {
        "ident" => Token::VarIdent(<&'a str>),
        "operator" => Token::Operator(<&'a str>),

        "whitespace" => Token::Whitespace(<&'a str>),
        "string literal" => Token::StringLiteral(<String>),
        "char literal" => Token::CharLiteral(<char>),
        "integer literal" => Token::IntegerLiteral(<i64>),
        "byte literal" => Token::ByteLiteral(<u8>),
        "float literal" => Token::FloatLiteral(<f64>),

        //"comment" => Comment,
        "newline" => Token::Newline,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "let" => Token::Let,
        "in" => Token::In,
        "case" => Token::Case,
        "of" => Token::Of,

        "|" => Token::Pipe, //'|'
        "," => Token::Comma, //','
        ";" => Token::Semi, //';'
        "v;" => Token::VirtualSemi, //';'
        "~" => Token::Tilde, //'`'
        "\\" => Token::Backslash, // '\\'
        "[" => Token::LBracket, //'['
        "{" => Token::LBrace, //'{' 
        "v{" => Token::VirtualLBrace,
        "(" => Token::LParen, //'('
        "]" => Token::RBracket, //']'
        "}" => Token::RBrace, //'}'
        "v}" => Token::VirtualRBrace,
        ")" => Token::RParen, //')'

        "=" => Token::Equals, 
        "->" => Token::Arrow,
        "=>" => Token::BigArrow,
        //"" => Error(TokenizerError),
    }
}

Sp<Rule>: Spanned<Rule, BytePos> =
    <l: @L> <rule: Rule> <r: @R> => pos::spanned(l, r, rule);


LBrace: () = {
    "{" => (),
    "v{" => (),

};
RBrace: () = {
    "}" => (),
    "v}" => (),

};

Semi: () = {
    ";" => (),
    "v;" => (),
    //<!> =
};

Comma: () = {
    "," => (),
    // Necessar
    //<!> => unimplemented!()//errors.push(<>.error)
};

CommaSep<Rule>: Vec<Rule> =
    <rules: (<Rule> Comma)*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };
        
SemiSep<Rule>: Vec<Rule> =
    <rules: (<Rule> Semi)*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };





pub Varid: Varid = "ident" => Varid::from_str(<>);


//pub Ident: Id = {
//    "ident" => {
//        ident_env.
//    }
//};


pub Operator: Varid = "operator" => Varid::from_str(<>);

pub Literal: Literal = {
    "integer literal" => Literal::Integer(<>),
    "string literal" => Literal::String(<>),
    "char literal" =>  Literal::Char(<>),
    "float literal" => Literal::Float(<>),
}


Binding: Binding = {
    <v:Varid> "=" <e:Expr> => Binding::new(v,e),
}

LetBindings: Vec<Binding> = {
    LBrace <SemiSep<Binding>> RBrace => <>,
    
}

AtomicExpr: Expr = {
    <Varid> => Expr::Ident(<>),
    <Literal> => Expr::Literal(<>),
    "(" <CommaSep<Expr>> ")" => Expr::Tuple(Tuple::new(<>)),
}

AppExpr: Expr = {
    AtomicExpr,
    <first:AtomicExpr> <rem:AtomicExpr+> => Expr::Application(Application::new(first, rem)),
}

InfixExpr: Expr = {
    AppExpr,
    "\\" <bindings:Varid*> "->" <e:Expr> => Expr::Lambda(Lambda::new(bindings, e)),
    <lhs:AppExpr> <op:Operator> <rhs:InfixExpr> => Expr::Operator(Box::new(lhs), op, Box::new(rhs)),
}

pub Expr: Expr = {
    InfixExpr,
    "let" LBrace <b:SemiSep<Binding>> RBrace "in" <e:Expr> => Expr::Let(b, Box::new(e)),
    "if" <cond:InfixExpr> "then" <t:InfixExpr> "else" <f:InfixExpr> => Expr::If(Box::new(cond), Box::new(t), Box::new(f)),
    //"case"
}

pub Program: Program = {
    <b:SemiSep<Binding>> => Program::Definitions(b)
}