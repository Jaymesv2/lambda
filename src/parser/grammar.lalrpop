use std::str::FromStr;

use crate::{
    ident_env::{IdentEnv, Id},
    parser::{
        parse_tree::*,
        pos::*,
        tokenizer::*,
        grammar::Error,
    }
};

use std::vec::Vec;

//grammar<'input, 'env, Id>(src: &'input str, type_cache: &TypeCache<Id, ArcType<Id>>, env: MutIdentEnv<'env, Id>, errors: ErrorEnv<'env, 'input>) where Id: Clone;

grammar<'a, 'b>(src: &'a str, ident_env: &'b mut IdentEnv);

extern {
    type Location = BytePos;
    type Error = Spanned<TokenizerError, BytePos>;

    enum Token<'a> {
        "ident" => Token::VarIdent(<&'a str>),
        "operator" => Token::Operator(<&'a str>),

        "whitespace" => Token::Whitespace(<&'a str>),
        "string literal" => Token::StringLiteral(<String>),
        "char literal" => Token::CharLiteral(<char>),
        "integer literal" => Token::IntegerLiteral(<i64>),
        "byte literal" => Token::ByteLiteral(<u8>),
        "float literal" => Token::FloatLiteral(<f64>),

        //"comment" => Comment,
        "newline" => Token::Newline,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "let" => Token::Let,
        "in" => Token::In,
        "case" => Token::Case,
        "of" => Token::Of,

        "|" => Token::Pipe, //'|'
        "," => Token::Comma, //','
        ";" => Token::Semi, //';'
        "v;" => Token::VirtualSemi, //';'
        "~" => Token::Tilde, //'`'
        "\\" => Token::Backslash, // '\\'
        "[" => Token::LBracket, //'['
        "{" => Token::LBrace, //'{' 
        "v{" => Token::VirtualLBrace,
        "(" => Token::LParen, //'('
        "]" => Token::RBracket, //']'
        "}" => Token::RBrace, //'}'
        "v}" => Token::VirtualRBrace,
        ")" => Token::RParen, //')'

        "=" => Token::Equals, 
        "->" => Token::Arrow,
        "=>" => Token::BigArrow,
        //"" => Error(TokenizerError),
    }
}

Sp<Rule>: Spanned<Rule, BytePos> =
    <l: @L> <rule: Rule> <r: @R> => pos::spanned(l, r, rule);


LBrace: () = {
    "{" => (),
    "v{" => (),

};
RBrace: () = {
    "}" => (),
    "v}" => (),

};

Semi: () = {
    ";" => (),
    "v;" => (),
    //<!> =
};

Comma: () = {
    "," => (),
    // Necessar
    //<!> => unimplemented!()//errors.push(<>.error)
};

CommaSep<Rule>: Vec<Rule> =
    <rules: (<Rule> Comma)*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };
        
SemiSep<Rule>: Vec<Rule> =
    <rules: (<Rule> Semi)*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };





//pub Varid: Varid = "ident" => Varid::from_str(<>);
//pub Operator: Varid = "operator" => Varid::from_str(<>);


pub Ident: Id = {
    <"ident"> => ident_env.bind(<>),
    "(" <"operator"> ")" => ident_env.bind(<>),
}

pub Literal: Literal = {
    "integer literal" => Literal::Integer(<>),
    "string literal" => Literal::String(<>),
    "char literal" =>  Literal::Char(<>),
    "float literal" => Literal::Float(<>),
}


Binding: Binding = {
    <v:Ident> "=" <e:Expr> => Binding::new(v,e),
}

LetLBrace: () = LBrace => ident_env.enter_scope();

Let: Expr = {
    "let" LetLBrace <b:SemiSep<Binding>> RBrace "in" <e:Expr> => {
        ident_env.leave_scope();
        Expr::Let(b, Box::new(e))
    },
}

LambdaBSlash: () = "\\" => ident_env.leave_scope();

// ends the scope
pub Lambda: Expr = {
    LambdaBSlash <args:Ident*> "->" <body:Expr> => {
        Expr::Lambda {
            args,
            body: Box::new(body)
        }
    },
}




AtomicExpr: Expr = {
    "ident" => Expr::Ident(ident_env.reference(<>)),
    <Literal> => Expr::Literal(<>),
    "(" <CommaSep<Expr>> ")" => Expr::Tuple(<>),
}

Application: Expr = <func:AtomicExpr> <args:AtomicExpr+> => Expr::Application {
    func: Box::new(func), 
    args,
};

AppExpr: Expr = {
    AtomicExpr,
    Application,
}



InfixExpr: Expr = {
    AppExpr,
    Lambda,
    <lhs:AppExpr> <op:"operator"> <rhs:InfixExpr> => Expr::Operator(Box::new(lhs), ident_env.reference(op), Box::new(rhs)),
}

pub Expr: Expr = {
    InfixExpr,
    Let,
    "if" <cond:InfixExpr> "then" <t:InfixExpr> "else" <f:InfixExpr> => Expr::If(Box::new(cond), Box::new(t), Box::new(f)),
    //"case"
}

pub Program: Program = {
    <b:SemiSep<Binding>> => Program::Definitions(b)
}